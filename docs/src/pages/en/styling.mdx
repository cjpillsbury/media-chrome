---
title: Styling
description: Styling Media Chrome
layout: ../../layouts/MainLayout.astro
---
import ComponentSandpack from "../../components/ComponentSandpack";

Arguably the primary purpose—the raison d'etre—of Media Chrome is creating custom media player user interfaces and experiences. It should come as no surprise that we provide a whole lot of ways to easily change its look and feel. In this guide, we'll go over some of the central ways to style your Media Chrome UI. From CSS variables and parts, to custom slottable icons, to built in styles in Media Chrome's container components, to out of the box breakpoints support for responsive design, Media Chrome makes it easy to customize the look and feel of a player UI that works best for your use case.

## The Basics

Just to have a baseline, let's start with a simple player UI built with Media Chrome that uses `<media-play-button>`.

<ComponentSandpack
  client:load
  html={`<media-controller>
  <video
    slot="media"
    src="https://stream.mux.com/A3VXy02VoUinw01pwyomEO3bHnG4P32xzV7u1j1FSzjNg/high.mp4"
    muted
  ></video>
  <media-play-button></media-play-button>
</media-controller>`}
/>

## Media Chrome + CSS Variables

While the component looks pretty good out of the box, maybe you want a slightly different color palette. To help make these styling cases easier, Media Chrome provides a set of well defined [CSS Custom Properties](https://developer.mozilla.org/en-US/docs/Web/CSS/--*) (also known as "CSS Variables"). Here's an example where we've changed the default color of the `<media-play-button>`'s icon, background, and hover background.

<ComponentSandpack
  client:load
  active="css"
  css={`media-play-button {
  --media-icon-color: lightpink;
  --media-control-background: rgb(135 206 250 / 0.7);
  --media-control-hover-background: rgb(32 178 170 / 0.7);
}`}
  html={`<media-controller>
  <video
    slot="media"
    src="https://stream.mux.com/A3VXy02VoUinw01pwyomEO3bHnG4P32xzV7u1j1FSzjNg/high.mp4"
    muted
  ></video>
  <media-play-button></media-play-button>
</media-controller>`}
/>

You may have noticed that the names of these variables make no specific mention of play buttons or even buttons at all. That's intentional. Many of our CSS variables are shared across many of our components, and we've intentionally named them to account for the scope of where they apply. If you only want them to apply to a particular component, you can use standard CSS selectors to scope them, like the the example above.

Each Media Chrome component has a pretty wide set of useful variables, including the color-related styles you see, font related styles, padding and sizing styles, and several others, which you can find in the reference section of each component's documentation. For example, you can find a full list of `<media-play-button>` CSS Variables [here](./components/media-play-button#css-variables).

{/* Mention + link to CSS style reference once added */}


## Media Chrome + Custom Icons

Being able to easily customize a variety of CSS properties is great, but that's not where custom styling stops with Media Chrome. For example, for any of our components with icons, you can override the defaults by passing in your version as a child element with the expected `slot` attribute, which identifies which state the icon is for. In our case, the `<media-play-button>` has both a `play` and a `pause` slot to customize what's shown when pressing the button will play or pause the media, respectively. Slots are actually a well defined [part of Web Components](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_templates_and_slots#adding_flexibility_with_slots), but for most use cases you don't need to worry about that. All you need to know is that adding the `slot` attribute with the expected name will ensure the element's use. Here's an example of adding custom play and pause SVG icons to our previous example. Notice that these SVGs still inherit our custom icon color.

<ComponentSandpack
  client:load
  css={`media-play-button {
  --media-icon-color: lightpink;
  --media-control-background: rgb(135 206 250 / 0.7);
  --media-control-hover-background: rgb(32 178 170 / 0.7);
}`}
  html={`<media-controller>
  <video
    slot="media"
    src="https://stream.mux.com/A3VXy02VoUinw01pwyomEO3bHnG4P32xzV7u1j1FSzjNg/high.mp4"
    muted
  ></video>
  <media-play-button>
    <svg slot="play" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
      <path d="M 21.457031 9.773438 L 5.109375 0.335938 C 4.328125 -0.113281 3.320312 -0.113281 2.546875 0.335938 C 1.753906 0.792969 1.261719 1.644531 1.261719 2.558594 L 1.261719 21.433594 C 1.261719 22.347656 1.753906 23.199219 2.539062 23.652344 C 2.929688 23.878906 3.375 24 3.828125 24 C 4.277344 24 4.722656 23.878906 5.109375 23.65625 L 21.457031 14.21875 C 22.246094 13.761719 22.738281 12.910156 22.738281 11.996094 C 22.738281 11.085938 22.246094 10.234375 21.457031 9.773438 Z M 20.230469 12.097656 L 3.882812 21.535156 C 3.847656 21.554688 3.808594 21.554688 3.769531 21.53125 C 3.734375 21.511719 3.710938 21.472656 3.710938 21.433594 L 3.710938 2.558594 C 3.710938 2.515625 3.734375 2.480469 3.769531 2.460938 C 3.785156 2.449219 3.804688 2.445312 3.828125 2.445312 C 3.847656 2.445312 3.867188 2.449219 3.882812 2.460938 L 20.226562 11.894531 C 20.265625 11.914062 20.289062 11.953125 20.289062 11.996094 C 20.289062 12.039062 20.265625 12.074219 20.230469 12.097656 Z M 20.230469 12.097656 "/>
    </svg>
    <svg slot="pause" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
      <path d="M 8.75 0 L 1.847656 0 C 1.265625 0 0.796875 0.46875 0.796875 1.046875 L 0.796875 22.949219 C 0.796875 23.53125 1.265625 24 1.847656 24 L 8.75 24 C 9.332031 24 9.800781 23.53125 9.800781 22.949219 L 9.800781 1.046875 C 9.800781 0.46875 9.332031 0 8.75 0 Z M 7.703125 21.902344 L 2.894531 21.902344 L 2.894531 2.097656 L 7.703125 2.097656 Z M 7.703125 21.902344 "/>
      <path d="M 22.152344 0 L 15.25 0 C 14.671875 0 14.199219 0.46875 14.199219 1.046875 L 14.199219 22.949219 C 14.199219 23.53125 14.671875 24 15.25 24 L 22.152344 24 C 22.730469 24 23.203125 23.53125 23.203125 22.949219 L 23.203125 1.046875 C 23.203125 0.46875 22.730469 0 22.152344 0 Z M 21.105469 21.902344 L 16.296875 21.902344 L 16.296875 2.097656 L 21.105469 2.097656 Z M 21.105469 21.902344 "/>
    </svg>
  </media-play-button>
</media-controller>`}
/>

{/* Should this be broken into a "Protip" or similar callout box? */}
There are a few things that we typically recommend when using custom icon images. First, while you can slot anything, we recommend SVGs, since they tend to be an efficient and scalable (hence the name) image format that is also easier to do things like tweak the dimensions of. Second, note that there is no `height`, `width`, or `fill` color defined on the SVGs. While not required, this is the best way to ensure that the sizing and coloring styles will be inherited by Media Chrome components. Additionally, note that these icons have both been constructed with a `viewBox="0 0 24 24"`. You can always use CSS to tweak these details, but this will help ensure that you won't have things like unintended whitespace or have to muck around with the padding of things like your button components.

Earlier, I mentioned that you can use whatever you want for your "icons". This includes other images, a `<span>` with some text, or whatever makes sense for your use case. Here's an example of using [Font Awesome Web Font icons](https://fontawesome.com/docs/web/setup/host-yourself/webfonts). If you take a look at the `custom-styles.css` file, you'll notice that I'm using slightly different CSS variables here (since the "icons" are actually font glyphs) and I also needed to apply some additional styles to the `<i>` element to make sure the sizes and layouts are consistent when toggling between "play" and "pause".

<ComponentSandpack
  client:load
  css={`media-play-button {
  --media-text-color: lightpink;
  --media-control-background: rgb(135 206 250 / 0.7);
  --media-control-hover-background: rgb(32 178 170 / 0.7);
  --media-font-size: 24px;
}

.mc-font-icon {
  width: 24px;
  text-align: center;
}
`}
  html={`<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet" />
<media-controller>
  <video
    slot="media"
    src="https://stream.mux.com/A3VXy02VoUinw01pwyomEO3bHnG4P32xzV7u1j1FSzjNg/high.mp4"
    muted
  ></video>
  <media-play-button>
    <i slot="play" class="mc-font-icon fa-solid fa-play"></i>
    <i slot="pause" class="mc-font-icon fa-solid fa-pause"></i>
  </media-play-button>
</media-controller>`}
/>

## Styling Multiple Components

In the previous example, I ended up using different CSS variables for my font-based icons vs. the SVG-based ones. This also applies for other color styles used in Media Chrome components. Since folks will typically want a consistent palette for their media player, Media Chrome has a couple of "color palette" CSS variables that work as defaults for some of the CSS variables used above: `--media-primary-color`, which you can think of as a "foreground" color, and `--media-secondary-color`, which you can think of as a "background" color. This makes styling multiple Media Chrome components easier with just a few CSS variables.

To demonstrate this, here's an example with several more components, including a range component (`<media-time-range>`), a text-based button component (`<media-playback-rate-button>`), and a text-based display component (`<media-time-display>`). All of these are styled using just 3 CSS variables. If you look at the `custom-styles.css`, you'll also see some of the related CSS variables commented out so you can experiment with their relationships.

<ComponentSandpack
  client:load
  active="css"
  css={`media-controller {
  --media-primary-color: lightpink;
  --media-secondary-color: rgb(135 206 250 / 0.7);
  /* Unfortunately, we currently still need to specifically apply the hover color :( */
  --media-control-hover-background: rgb(32 178 170 / 0.7);
  /* Uncomment any of these to see how the more specific CSS variables relate to primary & secondary */
  /* These are CSS variables that will default to the primary color if they are unset but take precedence if they are set */
  /*
  --media-icon-color: lightyellow;
  --media-text-color: lightgreen;
  --media-range-thumb-background: hotpink;
  --media-range-bar-color: indianred;
  */
  /* These are CSS variables that will default to the secondary color if they are unset but take precedence if they are set */
  /*
  --media-control-background: lightslategray;
  --media-preview-background: mediumslateblue;
  */
}`}
  html={`<media-controller>
  <video
    slot="media"
    src="https://stream.mux.com/A3VXy02VoUinw01pwyomEO3bHnG4P32xzV7u1j1FSzjNg/high.mp4"
    muted
  ></video>
  <div>
    <media-play-button></media-play-button>
    <media-time-display></media-time-display>
    <media-time-range></media-time-range>
    <media-playback-rate-button></media-playback-rate-button>
    <media-captions-button></media-captions-button>
    <media-airplay-button></media-airplay-button>
  </div>
</media-controller>`}
  hiddenCss={"div { font-size: 0; }"}
/>

## Conditional styling with media attributes

In the previous example, we added several components, including a captions button and an airplay button. But what if your video doesn't have any closed captions or subtitles? What if you're in a browser that doesn't support AirPlay? As you may already know, Media Chrome works by passing around different media state to its components, including the Media Controller component itself. Because this state will show up as attributes on the relevant components, we can use standard [CSS attribute selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors) to change styles based on those attributes.

Though not the only use of this strategy, one of the most common use cases is hiding or disabling components. In the example below, I've added some attribute selectors to hide the captions and airplay button based on the relevant state. Additionally, I've added a toy "banner" that uses `<media-text-display>` (to automatically get our Media Chrome CSS variable styles!) that should hide once the video has started playing (even if it's subsequently paused). For details on these attributes, check out the components in question. Just like our CSS variables, you can find out what media attributes will be passed to a particular component by checking the reference section of the component's docs. For example, the list of the airplay button's media attributes can be found [here](./components/media-airplay-button#media-ui-attributes).

<ComponentSandpack
  client:load
  active="css"
  css={`media-controller {
  --media-primary-color: lightpink;
  --media-secondary-color: rgb(135 206 250 / 0.7);
  --media-control-hover-background: rgb(32 178 170 / 0.7);
}

/* This just lets us still "click to play", even when clicking where the banner is. */
.banner {
  pointer-events: none;
}

/*
  Stop showing the banner once playback has begun. Since <media-text-display> doesn't
  receive the "mediahasplayed" attribute, we can simply target <media-controller>, which
  will get all media state updates.
*/
media-controller[mediahasplayed] .banner {
  display: none;
}

/* Do not show the airplay button unless AirPlay is available */
media-airplay-button[mediaairplayunavailable] {
  display: none;
}

/* Do not show the captions button if there are no captions for the media */
media-captions-button:not([mediasubtitleslist]) {
  display: none;
}`}
  html={`<media-controller>
  <video
    slot="media"
    src="https://stream.mux.com/A3VXy02VoUinw01pwyomEO3bHnG4P32xzV7u1j1FSzjNg/high.mp4"
    muted
  ></video>
  <media-text-display class="banner">I am a banner</media-text-display>
  <div>
    <media-play-button></media-play-button>
    <media-time-display></media-time-display>
    <media-time-range></media-time-range>
    <media-playback-rate-button></media-playback-rate-button>
    <media-captions-button></media-captions-button>
    <media-airplay-button></media-airplay-button>
  </div>
</media-controller>`}
  hiddenCss={"div { font-size: 0; }"}
/>

## Built in container styling

As the custom icon examples above show, updating the look and feel of player UIs with Media Chrome is more than just convenient CSS. We also mentioned at the beginning that you can get a lot of solid styling just by taking advantage of our built in components and functionality. Yet another way we try to bring this easy customization together is through some built in styling and layout you get from Media Chrome's container components. This next example will show you how to take advantage of these, even moreso when used together with what's possible with CSS in Media Chrome.

<ComponentSandpack
  client:load
  css={`media-controller {
  --media-primary-color: lightpink;
  --media-secondary-color: rgb(135 206 250 / 0.7);
  --media-control-hover-background: rgb(32 178 170 / 0.7);
}

/* This is how to style the "top-chrome" components differently */
media-controller [slot="top-chrome"] {
  --media-control-padding: 5px;
  --media-secondary-color: rgb(135 206 250 / 0.2);
}

/* This is how to style the "centered-chrome" components differently */
media-controller [slot="centered-chrome"] {
  border-radius: 50%;
  /* You could also use standard CSS properties for several of these */
  --media-control-padding: 2px;
  --media-control-height: 40px;
  --media-secondary-color: none;
  --media-control-hover-background: rgb(125, 125, 125, 0.25);
}

/* Do not show the airplay button unless AirPlay is available */
media-airplay-button[mediaairplayunavailable] {
  display: none;
}

/* Do not show the captions button if there are no captions for the media */
media-captions-button:not([mediasubtitleslist]) {
  display: none;
}`}
  html={`<media-controller>
  <video
    slot="media"
    src="https://stream.mux.com/A3VXy02VoUinw01pwyomEO3bHnG4P32xzV7u1j1FSzjNg/high.mp4"
    muted
  ></video>
  <media-text-display slot="top-chrome">My Video Trailer</media-text-display>
  <media-play-button slot="centered-chrome"></media-play-button>
  <!-- Adjust the "page" width to see how <media-time-range> and the buttons scale -->
  <media-control-bar>
    <media-play-button></media-play-button>
    <media-seek-backward-button></media-seek-backward-button>
    <media-seek-forward-button></media-seek-forward-button>
    <media-mute-button></media-mute-button>
    <media-volume-range></media-volume-range>
    <media-time-display></media-time-display>
    <media-time-range></media-time-range>
    <media-playback-rate-button></media-playback-rate-button>
    <media-captions-button></media-captions-button>
    <media-airplay-button></media-airplay-button>
  </media-control-bar>
  <!-- Uncomment to see how a <div> would render the components instead -->
  <!--
  <div>
    <media-play-button></media-play-button>
    <media-seek-backward-button></media-seek-backward-button>
    <media-seek-forward-button></media-seek-forward-button>
    <media-mute-button></media-mute-button>
    <media-volume-range></media-volume-range>
    <media-time-display></media-time-display>
    <media-time-range></media-time-range>
    <media-playback-rate-button></media-playback-rate-button>
    <media-captions-button></media-captions-button>
    <media-airplay-button></media-airplay-button>
  </div>
  -->

</media-controller>`}
  hiddenCss={"div { font-size: 0; }"}
/>

When it comes to our container components, you've actually been working with one of them from the beginning, albeit a special one: `<media-controller>`. Just like our button icon slots, the Media Controller container component has some well defined slots that will position components in different "regions" above the video. In this example, we're using the `slot="top-chrome"` and `slot="centered-chrome"` to add a title and "big play button", respectively. Note that our `slot="top-chrome"` component is positioned at the top left (similar to the other components we've been using, which were positioned at the bottom left), whereas our `slot="centered-chrome"` component is (shockingly) centered over the video. If you take a look at the `custom-styles.css`, you can also see how we're using some attribute selectors and CSS variables to apply some general styles and then tweak or override them for the components in each slotted region.

{/* Add a link to the Media Controller slots once that's updated */}

In the example, we've also replaced the `<div>` we were using to lay out our Media Chrome components with a second container component, `<media-control-bar>`. This gives us a few things automatically. First, if you either resize the "page" or remove some of the components, you'll see that the `<media-time-range>` will automatically grow to take up as much real estate is available to make seeking easier. Second, you can see how the components will automatically scale based on the available real estate. Finally, by using it with the `<media-controller>`, it will automatically grow to fill the entire width of the controller UI.

## Responsive CSS design with Media Controller breakpoints

So far, we've seen a couple of ways to easily "react" to the environment where the player UI is being viewed. Earlier, we showed how we can use particular media UI attributes to hide components when AirPlay or captions are unavailable. And in the previous example, we've seen how we can take advantage of Media Chrome's container components to automatically scale based on the available real estate. For folks familiar with "responsive design," you'll know that you can do a good amount of "app-"" or page-level styling using [CSS `@media` queries](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries). Unfortunately, for complex components like a media player UI, it's much more common to want to change the look and feel based on the player's size, not the page. And we're still anxiously await more [robust support](https://developer.mozilla.org/en-US/docs/Web/CSS/@container) for [CSS `@container` queries](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Container_Queries), which would be a great fit for this kind of responsive UI.

Since we know this is typically how most folks would want to build a responsive player UI, we've made sure it's easy for folks to do by building in a concept of "breakpoints" for `<media-controller>`. In the example below, you can see a basic implementation of a "mobile first" responsive design, where we apply the most generic styles for the smallest, "mobile" UI and then override them as the player UI gets larger. Like earlier examples, we can take advantage of attribute selectors, this time using `breakpointmd` for our standard "desktop" UI cutoff. I've also included a simple "extra large" (`breakpointxl`) example that makes all of the controls larger (NOTE: For this XL example, you'll probably need to open the example in Code Sandbox). And, like many features in Media Chrome, while we have some reasonable default values, you may {/* Add link to Responsive Design and/or Media Controller when ready */}define your own breakpoint cutoffs for more advanced customization.

<ComponentSandpack
  client:load
  active="css"
  css={`media-controller {
  --media-primary-color: lightpink;
  --media-secondary-color: rgb(135 206 250 / 0.7);
  --media-control-hover-background: rgb(32 178 170 / 0.7);
}

/* Since our breakpoints implementation is a "mobile-first" approach, we'll hide the "desktop only" items by default */
media-controller .desktop-only {
  --media-control-display: none;
}

/* Then, when the <media-controller> size is larger, we'll show the "desktop only" components and hide the "mobile only" ones */
/* NOTE: Here, we're using breakpointmd for "desktop" for demonstration purposes, but you may want to consider using breakpointlg instead. */
media-controller[breakpointmd] .desktop-only {
  --media-control-display: unset;
}

media-controller[breakpointmd] .mobile-only {
  --media-control-display: none;
}

/* Lastly, we can make our components sizing bigger when media-controller and the UI is particularly large */
/* NOTE: To see this in action, you'll likely need to open in Code Sandbox and then open the "app"/page in a new window. */
media-controller[breakpointxl] {
  --media-control-padding: 20px;
  --media-control-height: 36px;
  --media-font-size: 36px;
}

/*
  Uncomment these if you want a quick visual indicator of the breakpoints as you resize the page. You can think of no breakpoint as "xs",
  which is part of our "mobile first responsive design" approach. Related to this "mobile first" approach, breakpoint attributess are
  "additive" from smaller to larger, so e.g. media-controller[breakpointmd] is the same as media-controller[breakpointsm][breakpointmd],
  since both attributes will be present on the media controller. This allows you to apply styles to smaller sizes and then override them
  as the size increases.
*/
/*
media-controller {
  --media-primary-color: red;
}
media-controller[breakpointsm] {
  --media-primary-color: orange;
}
media-controller[breakpointmd] {
  --media-primary-color: yellow;
}
media-controller[breakpointlg] {
  --media-primary-color: green;
}
media-controller[breakpointxl] {
  --media-primary-color: blue;
}
*/

media-controller [slot="centered-chrome"] {
  border-radius: 50%;
  --media-control-padding: 2px;
  --media-control-height: 40px;
  --media-secondary-color: none;
  --media-control-hover-background: rgb(125, 125, 125, 0.25);
}

/* Do not show the airplay button unless AirPlay is available */
media-airplay-button[mediaairplayunavailable] {
  display: none;
}

/* Do not show the volume range unless volume control is available (e.g. many mobile devices require device-level control for volume) */
media-volume-range[mediavolumeunavailable] {
  display: none;
}

/* Do not show the captions button if there are no captions for the media */
media-captions-button:not([mediasubtitleslist]) {
  display: none;
}`}
  html={`<!-- Add the breakpoints="" below to see an example of changing the small breakpoint cutoff -->
<!-- <media-controller breakpoints="sm:412"> -->
<media-controller>
  <video
    slot="media"
    src="https://stream.mux.com/A3VXy02VoUinw01pwyomEO3bHnG4P32xzV7u1j1FSzjNg/high.mp4"
    playsinline
    muted
    crossorigin
  >
    <track
      label="thumbnails"
      default
      kind="metadata"
      src="https://image.mux.com/A3VXy02VoUinw01pwyomEO3bHnG4P32xzV7u1j1FSzjNg/storyboard.vtt"
    />
  </video>
  <div class="mobile-only" slot="centered-chrome">
    <media-seek-backward-button></media-seek-backward-button>
    <media-play-button></media-play-button>
    <media-seek-forward-button></media-seek-forward-button>
  </div>
  <media-control-bar>
    <media-play-button class="desktop-only"></media-play-button>
    <media-seek-backward-button class="desktop-only"></media-seek-backward-button>
    <media-seek-forward-button class="desktop-only"></media-seek-forward-button>
    <media-mute-button></media-mute-button>
    <media-volume-range></media-volume-range>
    <media-time-display></media-time-display>
    <media-time-range></media-time-range>
    <media-playback-rate-button></media-playback-rate-button>
    <media-captions-button></media-captions-button>
    <media-airplay-button></media-airplay-button>
  </media-control-bar>
</media-controller>`}
/>

## More complex component CSS

For the majority of our components


<ComponentSandpack
  client:load
  active="css"
  css={`media-time-range {
    --media-primary-color: lightpink;
    --media-secondary-color: rgb(135 206 250 / 0.7);
    --media-control-hover-background: rgb(32 178 170 / 0.7);
}

media-time-range::part(preview-box) {
    --media-primary-color: lightseagreen;
    --media-secondary-color: rgb(135 206 250);
    --media-control-hover-background: rgb(32 178 170);
    --media-preview-time-text-shadow: initial;
}

media-controller:not([userinactive])::part(gesture-layer) {
  background-color: rgb(0 0 0 / 0.2);
}
`}
  html={`<media-controller>
  <video
    slot="media"
    src="https://stream.mux.com/A3VXy02VoUinw01pwyomEO3bHnG4P32xzV7u1j1FSzjNg/high.mp4"
    crossorigin
    muted
  >
    <track
      label="thumbnails"
      default
      kind="metadata"
      src="https://image.mux.com/A3VXy02VoUinw01pwyomEO3bHnG4P32xzV7u1j1FSzjNg/storyboard.vtt"
    />
  </video>
  <media-control-bar>
    <media-time-range><div slot="current">Test</div></media-time-range>
  </media-control-bar>
</media-controller>`}
/>

{/* Would love to figure out how to get this example working with Sandpack! If we can't, we should at least add it to an official code sandbox and/or our examples. */}
{/*
<ComponentSandpack
  client:load
  height={550}
  files={{
    '/play.svg': `<?xml version="1.0" encoding="iso-8859-1"?>
<svg
  id="play"
  xmlns="http://www.w3.org/2000/svg"
  viewBox="0 0 58.752 58.752"
>
  <path
    d="M52.524,23.925L12.507,0.824c-1.907-1.1-4.376-1.097-6.276,0C4.293,1.94,3.088,4.025,3.088,6.264v46.205
    c0,2.24,1.204,4.325,3.131,5.435c0.953,0.555,2.042,0.848,3.149,0.848c1.104,0,2.192-0.292,3.141-0.843l40.017-23.103
    c1.936-1.119,3.138-3.203,3.138-5.439C55.663,27.134,54.462,25.05,52.524,23.925z M49.524,29.612L9.504,52.716
    c-0.082,0.047-0.18,0.052-0.279-0.005c-0.084-0.049-0.137-0.142-0.137-0.242V6.263c0-0.1,0.052-0.192,0.14-0.243
    c0.042-0.025,0.09-0.038,0.139-0.038c0.051,0,0.099,0.013,0.142,0.038l40.01,23.098c0.089,0.052,0.145,0.147,0.145,0.249
    C49.663,29.47,49.611,29.561,49.524,29.612z"
  />
</svg>`,
    '/pause.svg': `<?xml version="1.0" encoding="iso-8859-1"?>
<svg
  id="pause"
  xmlns="http://www.w3.org/2000/svg"
  viewBox="0 0 332.145 332.146"
>
  <path
    d="M121.114,0H25.558c-8.017,0-14.517,6.5-14.517,14.515v303.114c0,8.017,6.5,14.517,14.517,14.517h95.556
    c8.017,0,14.517-6.5,14.517-14.517V14.515C135.631,6.499,129.131,0,121.114,0z M106.6,303.113H40.072V29.031H106.6V303.113z"
  />
  <path
    d="M306.586,0h-95.541c-8.018,0-14.518,6.5-14.518,14.515v303.114c0,8.017,6.5,14.517,14.518,14.517h95.541
    c8.016,0,14.518-6.5,14.518-14.517V14.515C321.102,6.499,314.602,0,306.586,0z M292.073,303.113h-66.514V29.031h66.514V303.113z"
  />
</svg>`
  }}
  html={`<style>
  media-play-button {
    --media-control-background: lightskyblue;
    --media-icon-color: lightpink;
    --media-control-hover-background: lightseagreen;
  }
</style>
<media-controller>
  <video
    slot="media"
    src="https://stream.mux.com/A3VXy02VoUinw01pwyomEO3bHnG4P32xzV7u1j1FSzjNg/high.mp4"
    muted
  ></video>
  <media-play-button>
    <svg slot="play"><use href="play.svg#play"/></svg>
    <svg slot="pause"><use href="pause.svg#pause"/></svg>
  </media-play-button>
</media-controller>`}
/> */}
